package deployment

import (
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"

	"polar-bear/internal/config"
	"polar-bear/internal/runtimemeta"
	"polar-bear/internal/web/view/shared"
)

templ ListView(
	start *time.Time,
	cfg *config.Config,
	rm *runtimemeta.RuntimeMeta,
	ns string,
	deploys []*appsv1.Deployment,
	nss []*corev1.Namespace,
) {
	@shared.Base("Deployments", start, cfg.DevMode, rm, nss, "", ns) {
		<header class="py-8">
			<h1 class="text-3xl font-extrabold">Deployments</h1>
		</header>
		<div class="space-y-5">
			<div class="px-6 py-3 bg-white shadow-md rounded-lg">
				@DeploymentList(ns, deploys)
			</div>
		</div>
	}
}

templ DeploymentList(ns string, deploys []*appsv1.Deployment) {
	<div id="ns-container" class="divide-y divide-solid">
		if len(deploys) > 0 {
			for _, deploy := range(deploys) {
				@DeploymentItem(deploy)
			}
		} else {
			No Deployments found in Namespace <i>{ ns }</i>
		}
	</div>
}

templ DeploymentItem(deploy *appsv1.Deployment) {
	<div class="py-3" id={ deploy.Name }>
		<div class="flex flex-row justify-between">
			@shared.KubernetesDeploymentSvg()
			<a
				class="hover:underline font-semibold flex-grow text-left pl-1 whitespace-nowrap overflow-hidden text-ellipsis"
				href={ shared.DeploymentLink(deploy.Namespace, deploy.Name) }
			>
				{ deploy.Name }
			</a>
			switch getDeploymentConditionType(deploy.Status.Conditions) {
				case appsv1.DeploymentAvailable:
					@shared.Badge("Available", "green")
				case appsv1.DeploymentProgressing:
					@shared.Badge("Progressing", "yellow")
				case appsv1.DeploymentReplicaFailure:
					@shared.Badge("Replica Failure", "red")
				default:
					@shared.Badge("Unknown", "gray")
			}
		</div>
	</div>
}

func getDeploymentConditionType(cs []appsv1.DeploymentCondition) appsv1.DeploymentConditionType {
	var mostRecent appsv1.DeploymentCondition
	for _, c := range cs {
		if c.LastTransitionTime.After(mostRecent.LastTransitionTime.Time) {
			mostRecent = c
		}
	}
	return mostRecent.Type
}
